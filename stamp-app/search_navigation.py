# This is a utility module for generating a representation of a search results navigation display
# configuration/setup based on a set of search results, the subset of search results that are to be
# displayed and a number of other display choices that can be made.
#
# This is useful when we have a large number of search results, know which search results we want to
# display, know how many search results to display at the same time, and we want to use the metaphor
# of pages to display the search results to a user in an UI. The representation can be generated
# declaratively by explicitly stating the key parameters, and the representation can then be passed
# to some other function responsible for generating the appropriate UI components and filling them
# with data. Exactly which UI components and how to style them is a different challenge.
#
# Here is an example of a representation:
#
# ['P', 'F', '...', '3', '4', '5*', '6', '7', '...', 'L', 'N']
#
# The representation above indicates that we want to display search results:
# * with 5 linked pages ('3', '4', '5', '6', '7').
# * showing that page 5 is the currently displayed page ('5*').
# * showing that there are more search results before page 3 and after page 7 ('...').
# * showing a link or button to the first page ('F') and last page 'L').
# * showing a link or button to the previous page ('P') and the next page ('N').
#
# The representation above was generated by invoing `linked_pages_representation`: with
#
# linked_pages_representation(5, 15, 5, True, True, True, True, True)
#
# where the positional arguments are:
# * 5: The current page.
# * 15: The total number of pages.
# * 5: The number of pages to have links. The current page is always the centermost page of those.
# * True: We want a first page link/button.
# * True: We want a last page link/button.
# * True: We want a previous page link/button.
# * True: We want a next page link/button.
# * True: We want to show that there are more pages. In the representation we use '...' (ellipsis).
#
# There are two functions in this module:
# * pages_representation. This assumes you know the number of pages to display and the current page
#   to display.
# * result_pages_representation. This assumes you know the number of search results, the
#   number of search results you want to display per page (rpp), and the first search result you
#   want to display. This function will then calculate the total number of pages and the current
#   page to display, and after that invoke `linked_pages_representation`.
#

# import typing
from typing import List
from pydantic import BaseModel
# import pytest


class ResultPagesSpecification(BaseModel):
    """A specification of how to construct a search results page with links."""
    page_count: int
    current_page: int
    linked_pages: List[int]
    next_page: bool
    previous_page: bool
    first_page: bool
    last_page: bool
    left_ellipsis: bool
    right_ellipsis: bool


def result_pages_specification(count: int,
                               start: int,
                               rpp: int,
                               linked_pages: int,
                               first_page: bool = False,
                               last_page: bool = False,
                               previous_page: bool = False,
                               next_page: bool = False) -> ResultPagesSpecification:
    """Specification of how to construct a search results page given `count` (number of items /
       search results), `start` (the first item / search result to  display) and `rpp` (the
       number of items / results per page to display)."""
    assert count >= 0
    assert start >= 0
    assert rpp > 0
    assert start % rpp == 0
    assert linked_pages >= 0

    # Calculate total number of pages
    page_count = count // rpp + 1
    # Calculate the current page number
    current_page = start // rpp + 1

    result = {"page_count": page_count,
              "current_page": current_page,
              "linked_pages": [],
              "next_page": next_page,
              "previous_page": previous_page,
              "first_page": first_page,
              "last_page": last_page}

    first = 0
    last = 0
    if linked_pages >= page_count:
        # All pages will have links
        first = 1
        last = page_count
    elif linked_pages == 0:
        first = 0
        last = -1
    elif linked_pages == 1:
        first = current_page
        last = current_page
    elif linked_pages > 1:
        # Calculate number of pages left and right of current page `n` that will have links. In the
        # case of an even number of linked pages, we link one more page to the left than to the
        # right.
        first = current_page - linked_pages // 2
        last = current_page + linked_pages // 2
        if linked_pages % 2 == 0:
            last -= 1
        # If we've overflowed to the left or right we need to adjust left and right
        if first <= 0:
            last = last + 1 - first
            first = 1
        if last > page_count:
            first = first - (last - page_count)
            last = page_count

    # Build representation with links
    for i in range(first, last+1):
        result["linked_pages"].append(i)

    # Check if first page, last page and ellipsis should be shown
    if 1 in result["linked_pages"]:
        result["first_page"] = False
    else:
        result["first_page"] = True
    if page_count in result["linked_pages"]:
        result["last_page"] = False
    else:
        result["last_page"] = True
    if result["linked_pages"][0] > 1:
        result["left_ellipsis"] = True
    else:
        result["left_ellipsis"] = False
    if result["linked_pages"][-1] < page_count:
        result["right_ellipsis"] = True
    else:
        result["right_ellipsis"] = False

    return result


def result_pages_representation(count: int,
                                start: int,
                                rpp: int,
                                linked_pages: int,
                                first_page: bool = False,
                                last_page: bool = False,
                                previous_page: bool = False,
                                next_page: bool = False,
                                left_ellipsis: bool = False,
                                right_ellipsis: bool = False):
    """Representation given `count` (number of items / search results), `start` (the first item /
       search result to  display) and `rpp` (the number of items / results per page to display)."""
    assert count >= 0
    assert start >= 0
    assert rpp > 0
    assert start % rpp == 0
    assert linked_pages >= 0

    # Calculate total number of pages
    page_count = count // rpp + 1
    # Calculate the current page number
    current_page = start // rpp + 1

    return linked_pages_representation(current_page,
                                       page_count,
                                       linked_pages,
                                       first_page,
                                       last_page,
                                       previous_page,
                                       next_page,
                                       ellipsis=False)


def linked_pages_representation(current_page: int,
                                page_count: int,
                                linked_pages: int,
                                first_page: bool = False,
                                last_page: bool = False,
                                previous_page: bool = False,
                                next_page: bool = False,
                                ellipsis: bool = False):
    """Navigation bar repesentation with linked pages and possibly ellipsis"""
    assert current_page >= 1
    assert current_page <= page_count
    assert page_count >= 0
    assert linked_pages >= 0

    first = 0
    last = 0
    result = []
    if linked_pages >= page_count:
        # All pages will have links
        first = 1
        last = page_count
    elif linked_pages == 0:
        first = 0
        last = -1
    elif linked_pages == 1:
        first = current_page
        last = current_page
    elif linked_pages > 1:
        # Calculate number of pages left and right of current page `n` that will have links. In the
        # case of an even number of linked pages, we link one more page to the left than to the
        # right.
        first = current_page - linked_pages // 2
        last = current_page + linked_pages // 2
        if linked_pages % 2 == 0:
            last -= 1
        # If we've overflowed to the left or right we need to adjust left and right
        if first <= 0:
            last = last + 1 - first
            first = 1
        if last > page_count:
            first = first - (last - page_count)
            last = page_count

    # Build representation with links
    for i in range(first, last+1):
        if i == current_page:
            result.append(f"{i}*")
        else:
            result.append(f"{i}")

    if ellipsis:
        if first > 1:
            result.insert(0, "...")
        if last < page_count:
            result.append("...")

    if first_page:
        result.insert(0, "F")
    if last_page:
        result.append("L")

    if previous_page:
        result.insert(0, "P")
    if next_page:
        result.append("N")

    return result


def test_page_count_2_linked_pages_0():
    assert linked_pages_representation(1, 2, 0) == []


def test_page_count_2_linked_pages_1():
    assert linked_pages_representation(1, 2, 1) == ['1*']
    assert linked_pages_representation(2, 2, 1) == ['2*']


def test_page_count_2_linked_pages_2():
    assert linked_pages_representation(1, 2, 2) == ['1*', '2']
    assert linked_pages_representation(2, 2, 2) == ['1', '2*']


def test_page_count_3_linked_pages_0():
    assert linked_pages_representation(1, 3, 0) == []


def test_page_count_3_linked_pages_1():
    assert linked_pages_representation(1, 3, 1) == ['1*']
    assert linked_pages_representation(2, 3, 1) == ['2*']
    assert linked_pages_representation(3, 3, 1) == ['3*']


def test_page_count_3_linked_pages_2():
    assert linked_pages_representation(1, 3, 2) == ['1*', '2']
    assert linked_pages_representation(2, 3, 2) == ['1', '2*']
    assert linked_pages_representation(3, 3, 2) == ['2', '3*']


def test_page_count_3_linked_pages_3():
    assert linked_pages_representation(1, 3, 3) == ['1*', '2', '3']
    assert linked_pages_representation(2, 3, 3) == ['1', '2*', '3']
    assert linked_pages_representation(3, 3, 3) == ['1', '2', '3*']


def test_page_count_4_linked_pages_0():
    assert linked_pages_representation(1, 4, 0) == []


def test_page_count_4_linked_pages_1():
    assert linked_pages_representation(1, 4, 1) == ['1*']
    assert linked_pages_representation(2, 4, 1) == ['2*']
    assert linked_pages_representation(3, 4, 1) == ['3*']
    assert linked_pages_representation(4, 4, 1) == ['4*']


def test_page_count_4_linked_pages_2():
    assert linked_pages_representation(1, 4, 2) == ['1*', '2']
    assert linked_pages_representation(2, 4, 2) == ['1', '2*']
    assert linked_pages_representation(3, 4, 2) == ['2', '3*']
    assert linked_pages_representation(4, 4, 2) == ['3', '4*']


def test_page_count_4_linked_pages_3():
    assert linked_pages_representation(1, 4, 3) == ['1*', '2', '3']
    assert linked_pages_representation(2, 4, 3) == ['1', '2*', '3']
    assert linked_pages_representation(3, 4, 3) == ['2', '3*', '4']
    assert linked_pages_representation(4, 4, 3) == ['2', '3', '4*']


def test_page_count_4_linked_pages_4():
    assert linked_pages_representation(1, 4, 4) == ['1*', '2', '3', '4']
    assert linked_pages_representation(2, 4, 4) == ['1', '2*', '3', '4']
    assert linked_pages_representation(3, 4, 4) == ['1', '2', '3*', '4']
    assert linked_pages_representation(4, 4, 4) == ['1', '2', '3', '4*']


def test_page_count_5_linked_pages_0():
    assert linked_pages_representation(1, 5, 0) == []


def test_page_count_5_linked_pages_1():
    assert linked_pages_representation(1, 5, 1) == ['1*']
    assert linked_pages_representation(2, 5, 1) == ['2*']
    assert linked_pages_representation(3, 5, 1) == ['3*']
    assert linked_pages_representation(4, 5, 1) == ['4*']
    assert linked_pages_representation(5, 5, 1) == ['5*']


def test_page_count_5_linked_pages_2():
    assert linked_pages_representation(1, 5, 2) == ['1*', '2']
    assert linked_pages_representation(2, 5, 2) == ['1', '2*']
    assert linked_pages_representation(3, 5, 2) == ['2', '3*']
    assert linked_pages_representation(4, 5, 2) == ['3', '4*']
    assert linked_pages_representation(5, 5, 2) == ['4', '5*']


def test_page_count_5_linked_pages_3():
    """Test 3 linked pages when page count is 5."""
    assert linked_pages_representation(1, 5, 3) == ['1*', '2', '3']
    assert linked_pages_representation(2, 5, 3) == ['1', '2*', '3']
    assert linked_pages_representation(3, 5, 3) == ['2', '3*', '4']
    assert linked_pages_representation(4, 5, 3) == ['3', '4*', '5']
    assert linked_pages_representation(5, 5, 3) == ['3', '4', '5*']


def test_page_count_5_linked_pages_4():
    """Test 4 linked pages when page count is 5."""
    assert linked_pages_representation(1, 5, 4) == ['1*', '2', '3', '4']
    assert linked_pages_representation(2, 5, 4) == ['1', '2*', '3', '4']
    assert linked_pages_representation(3, 5, 4) == ['1', '2', '3*', '4']
    assert linked_pages_representation(4, 5, 4) == ['2', '3', '4*', '5']
    assert linked_pages_representation(5, 5, 4) == ['2', '3', '4', '5*']


def test_page_count_5_linked_pages_5():
    """Test 5 linked pages when page count is 5."""
    assert linked_pages_representation(1, 5, 5) == ['1*', '2', '3', '4', '5']
    assert linked_pages_representation(2, 5, 5) == ['1', '2*', '3', '4', '5']
    assert linked_pages_representation(3, 5, 5) == ['1', '2', '3*', '4', '5']
    assert linked_pages_representation(4, 5, 5) == ['1', '2', '3', '4*', '5']
    assert linked_pages_representation(5, 5, 5) == ['1', '2', '3', '4', '5*']


def test_first_last_page_ellipsis():
    assert linked_pages_representation(2, 15, 5, True, True, False, False, True) == \
           ['F', '1', '2*', '3', '4', '5', '...', 'L']
    assert linked_pages_representation(5, 15, 5, True, True, False, False, True) == \
           ['F', '...', '3', '4', '5*', '6', '7', '...', 'L']


def test_first_last_page_ellipsis_previous_next_page():
    assert linked_pages_representation(2, 15, 5, True, True, True, True, True) == \
           ['P', 'F', '1', '2*', '3', '4', '5', '...', 'L', 'N']
    assert linked_pages_representation(5, 15, 5, True, True, True, True, True) == \
           ['P', 'F', '...', '3', '4', '5*', '6', '7', '...', 'L', 'N']
